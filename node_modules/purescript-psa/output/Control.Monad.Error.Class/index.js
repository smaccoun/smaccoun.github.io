// Generated by psc version 0.10.7

// | This module defines the `MonadError` type class and its instances.
"use strict";
var Prelude = require("../Prelude");
var Data_Maybe = require("../Data.Maybe");
var Data_Either = require("../Data.Either");
var Data_Function = require("../Data.Function");
var Data_Unit = require("../Data.Unit");

// | The `MonadError` type class represents those monads which support errors via

// | `throwError` and `catchError`.

// |

// | - `throwError e` throws the error `e`

// | - `catchError x f` calls the error handler `f` if an error is thrown during the

// |   evaluation of `x`.

// |

// | An implementation is provided for `ErrorT`, and for other monad transformers

// | defined in this library.

// |

// | Laws:

// |

// | - Left zero: `throwError e >>= f = throwError e`

// | - Catch: `catchError (throwError e) f = f e`

// | - Pure: `catchError (pure a) f = pure a`

// |
var MonadError = function (__superclass_Control$dotMonad$dotMonad_0, catchError, throwError) {
    this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
    this.catchError = catchError;
    this.throwError = throwError;
};

// | The `MonadError` type class represents those monads which support errors via

// | `throwError` and `catchError`.

// |

// | - `throwError e` throws the error `e`

// | - `catchError x f` calls the error handler `f` if an error is thrown during the

// |   evaluation of `x`.

// |

// | An implementation is provided for `ErrorT`, and for other monad transformers

// | defined in this library.

// |

// | Laws:

// |

// | - Left zero: `throwError e >>= f = throwError e`

// | - Catch: `catchError (throwError e) f = f e`

// | - Pure: `catchError (pure a) f = pure a`

// |
var throwError = function (dict) {
    return dict.throwError;
};
var monadErrorMaybe = new MonadError(function () {
    return Data_Maybe.monadMaybe;
}, function (v) {
    return function (v1) {
        if (v instanceof Data_Maybe.Nothing) {
            return v1(Data_Unit.unit);
        };
        if (v instanceof Data_Maybe.Just) {
            return new Data_Maybe.Just(v.value0);
        };
        throw new Error("Failed pattern match at Control.Monad.Error.Class line 55, column 3 - line 55, column 33: " + [ v.constructor.name, v1.constructor.name ]);
    };
}, Data_Function["const"](Data_Maybe.Nothing.value));
var monadErrorEither = new MonadError(function () {
    return Data_Either.monadEither;
}, function (v) {
    return function (v1) {
        if (v instanceof Data_Either.Left) {
            return v1(v.value0);
        };
        if (v instanceof Data_Either.Right) {
            return new Data_Either.Right(v.value0);
        };
        throw new Error("Failed pattern match at Control.Monad.Error.Class line 50, column 3 - line 50, column 30: " + [ v.constructor.name, v1.constructor.name ]);
    };
}, Data_Either.Left.create);

// | The `MonadError` type class represents those monads which support errors via

// | `throwError` and `catchError`.

// |

// | - `throwError e` throws the error `e`

// | - `catchError x f` calls the error handler `f` if an error is thrown during the

// |   evaluation of `x`.

// |

// | An implementation is provided for `ErrorT`, and for other monad transformers

// | defined in this library.

// |

// | Laws:

// |

// | - Left zero: `throwError e >>= f = throwError e`

// | - Catch: `catchError (throwError e) f = f e`

// | - Pure: `catchError (pure a) f = pure a`

// |
var catchError = function (dict) {
    return dict.catchError;
};

// | This function allows you to provide a predicate for selecting the

// | exceptions that you're interested in, and handle only those exceptons.

// | If the inner computation throws an exception, and the predicate returns

// | Nothing, then the whole computation will still fail with that exception.
var catchJust = function (dictMonadError) {
    return function (p) {
        return function (act) {
            return function (handler) {
                var handle = function (e) {
                    var $12 = p(e);
                    if ($12 instanceof Data_Maybe.Nothing) {
                        return throwError(dictMonadError)(e);
                    };
                    if ($12 instanceof Data_Maybe.Just) {
                        return handler($12.value0);
                    };
                    throw new Error("Failed pattern match at Control.Monad.Error.Class line 44, column 5 - line 46, column 26: " + [ $12.constructor.name ]);
                };
                return catchError(dictMonadError)(act)(handle);
            };
        };
    };
};
module.exports = {
    MonadError: MonadError, 
    catchError: catchError, 
    catchJust: catchJust, 
    throwError: throwError, 
    monadErrorEither: monadErrorEither, 
    monadErrorMaybe: monadErrorMaybe
};
