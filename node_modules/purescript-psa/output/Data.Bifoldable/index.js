// Generated by psc version 0.10.7
"use strict";
var Prelude = require("../Prelude");
var Control_Apply = require("../Control.Apply");
var Data_Monoid = require("../Data.Monoid");
var Data_Monoid_Conj = require("../Data.Monoid.Conj");
var Data_Monoid_Disj = require("../Data.Monoid.Disj");
var Data_Monoid_Dual = require("../Data.Monoid.Dual");
var Data_Monoid_Endo = require("../Data.Monoid.Endo");
var Data_Newtype = require("../Data.Newtype");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Control_Applicative = require("../Control.Applicative");
var Data_Unit = require("../Data.Unit");
var Control_Category = require("../Control.Category");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Function = require("../Data.Function");

// | `Bifoldable` represents data structures with two type arguments which can be

// | folded.

// |

// | A fold for such a structure requires two step functions, one for each type

// | argument. Type class instances should choose the appropriate step function based

// | on the type of the element encountered at each point of the fold.

// |

// | Default implementations are provided by the following functions:

// |

// | - `bifoldrDefault`

// | - `bifoldlDefault`

// | - `bifoldMapDefaultR`

// | - `bifoldMapDefaultL`

// |

// | Note: some combinations of the default implementations are unsafe to

// | use together - causing a non-terminating mutually recursive cycle.

// | These combinations are documented per function.
var Bifoldable = function (bifoldMap, bifoldl, bifoldr) {
    this.bifoldMap = bifoldMap;
    this.bifoldl = bifoldl;
    this.bifoldr = bifoldr;
};

// | `Bifoldable` represents data structures with two type arguments which can be

// | folded.

// |

// | A fold for such a structure requires two step functions, one for each type

// | argument. Type class instances should choose the appropriate step function based

// | on the type of the element encountered at each point of the fold.

// |

// | Default implementations are provided by the following functions:

// |

// | - `bifoldrDefault`

// | - `bifoldlDefault`

// | - `bifoldMapDefaultR`

// | - `bifoldMapDefaultL`

// |

// | Note: some combinations of the default implementations are unsafe to

// | use together - causing a non-terminating mutually recursive cycle.

// | These combinations are documented per function.
var bifoldr = function (dict) {
    return dict.bifoldr;
};

// | Traverse a data structure, accumulating effects using an `Applicative` functor,

// | ignoring the final result.
var bitraverse_ = function (dictBifoldable) {
    return function (dictApplicative) {
        return function (f) {
            return function (g) {
                return bifoldr(dictBifoldable)(function ($18) {
                    return Control_Apply.applySecond(dictApplicative["__superclass_Control.Apply.Apply_0"]())(f($18));
                })(function ($19) {
                    return Control_Apply.applySecond(dictApplicative["__superclass_Control.Apply.Apply_0"]())(g($19));
                })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
            };
        };
    };
};

// | A version of `bitraverse_` with the data structure as the first argument.
var bifor_ = function (dictBifoldable) {
    return function (dictApplicative) {
        return function (t) {
            return function (f) {
                return function (g) {
                    return bitraverse_(dictBifoldable)(dictApplicative)(f)(g)(t);
                };
            };
        };
    };
};

// | Collapse a data structure, collecting effects using an `Applicative` functor,

// | ignoring the final result.
var bisequence_ = function (dictBifoldable) {
    return function (dictApplicative) {
        return bitraverse_(dictBifoldable)(dictApplicative)(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn));
    };
};

// | `Bifoldable` represents data structures with two type arguments which can be

// | folded.

// |

// | A fold for such a structure requires two step functions, one for each type

// | argument. Type class instances should choose the appropriate step function based

// | on the type of the element encountered at each point of the fold.

// |

// | Default implementations are provided by the following functions:

// |

// | - `bifoldrDefault`

// | - `bifoldlDefault`

// | - `bifoldMapDefaultR`

// | - `bifoldMapDefaultL`

// |

// | Note: some combinations of the default implementations are unsafe to

// | use together - causing a non-terminating mutually recursive cycle.

// | These combinations are documented per function.
var bifoldl = function (dict) {
    return dict.bifoldl;
};

// | A default implementation of `bifoldMap` using `bifoldr`.

// |

// | Note: when defining a `Bifoldable` instance, this function is unsafe to

// | use in combination with `bifoldrDefault`.
var bifoldMapDefaultR = function (dictBifoldable) {
    return function (dictMonoid) {
        return function (f) {
            return function (g) {
                return function (p) {
                    return bifoldr(dictBifoldable)(function ($20) {
                        return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f($20));
                    })(function ($21) {
                        return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(g($21));
                    })(Data_Monoid.mempty(dictMonoid))(p);
                };
            };
        };
    };
};

// | A default implementation of `bifoldMap` using `bifoldl`.

// |

// | Note: when defining a `Bifoldable` instance, this function is unsafe to

// | use in combination with `bifoldlDefault`.
var bifoldMapDefaultL = function (dictBifoldable) {
    return function (dictMonoid) {
        return function (f) {
            return function (g) {
                return function (p) {
                    return bifoldl(dictBifoldable)(function (m) {
                        return function (a) {
                            return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(m)(f(a));
                        };
                    })(function (m) {
                        return function (b) {
                            return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(m)(g(b));
                        };
                    })(Data_Monoid.mempty(dictMonoid))(p);
                };
            };
        };
    };
};

// | `Bifoldable` represents data structures with two type arguments which can be

// | folded.

// |

// | A fold for such a structure requires two step functions, one for each type

// | argument. Type class instances should choose the appropriate step function based

// | on the type of the element encountered at each point of the fold.

// |

// | Default implementations are provided by the following functions:

// |

// | - `bifoldrDefault`

// | - `bifoldlDefault`

// | - `bifoldMapDefaultR`

// | - `bifoldMapDefaultL`

// |

// | Note: some combinations of the default implementations are unsafe to

// | use together - causing a non-terminating mutually recursive cycle.

// | These combinations are documented per function.
var bifoldMap = function (dict) {
    return dict.bifoldMap;
};

// | A default implementation of `bifoldl` using `bifoldMap`.

// |

// | Note: when defining a `Bifoldable` instance, this function is unsafe to

// | use in combination with `bifoldMapDefaultL`.
var bifoldlDefault = function (dictBifoldable) {
    return function (f) {
        return function (g) {
            return function (z) {
                return function (p) {
                    return Data_Newtype.unwrap(Data_Monoid_Endo.newtypeEndo)(Data_Newtype.unwrap(Data_Monoid_Dual.newtypeDual)(bifoldMap(dictBifoldable)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo))(function ($22) {
                        return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Data_Function.flip(f)($22)));
                    })(function ($23) {
                        return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Data_Function.flip(g)($23)));
                    })(p)))(z);
                };
            };
        };
    };
};

// | A default implementation of `bifoldr` using `bifoldMap`.

// |

// | Note: when defining a `Bifoldable` instance, this function is unsafe to

// | use in combination with `bifoldMapDefaultR`.
var bifoldrDefault = function (dictBifoldable) {
    return function (f) {
        return function (g) {
            return function (z) {
                return function (p) {
                    return Data_Newtype.unwrap(Data_Monoid_Endo.newtypeEndo)(bifoldMap(dictBifoldable)(Data_Monoid_Endo.monoidEndo)(function ($24) {
                        return Data_Monoid_Endo.Endo(f($24));
                    })(function ($25) {
                        return Data_Monoid_Endo.Endo(g($25));
                    })(p))(z);
                };
            };
        };
    };
};

// | Fold a data structure, accumulating values in a monoidal type.
var bifold = function (dictBifoldable) {
    return function (dictMonoid) {
        return bifoldMap(dictBifoldable)(dictMonoid)(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn));
    };
};

// | Test whether a predicate holds at any position in a data structure.
var biany = function (dictBifoldable) {
    return function (dictBooleanAlgebra) {
        return function (p) {
            return function (q) {
                return function ($26) {
                    return Data_Newtype.unwrap(Data_Monoid_Disj.newtypeDisj)(bifoldMap(dictBifoldable)(Data_Monoid_Disj.monoidDisj(dictBooleanAlgebra["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]()))(function ($27) {
                        return Data_Monoid_Disj.Disj(p($27));
                    })(function ($28) {
                        return Data_Monoid_Disj.Disj(q($28));
                    })($26));
                };
            };
        };
    };
};

// | Test whether a predicate holds at all positions in a data structure.
var biall = function (dictBifoldable) {
    return function (dictBooleanAlgebra) {
        return function (p) {
            return function (q) {
                return function ($29) {
                    return Data_Newtype.unwrap(Data_Monoid_Conj.newtypeConj)(bifoldMap(dictBifoldable)(Data_Monoid_Conj.monoidConj(dictBooleanAlgebra["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]()))(function ($30) {
                        return Data_Monoid_Conj.Conj(p($30));
                    })(function ($31) {
                        return Data_Monoid_Conj.Conj(q($31));
                    })($29));
                };
            };
        };
    };
};
module.exports = {
    Bifoldable: Bifoldable, 
    biall: biall, 
    biany: biany, 
    bifold: bifold, 
    bifoldMap: bifoldMap, 
    bifoldMapDefaultL: bifoldMapDefaultL, 
    bifoldMapDefaultR: bifoldMapDefaultR, 
    bifoldl: bifoldl, 
    bifoldlDefault: bifoldlDefault, 
    bifoldr: bifoldr, 
    bifoldrDefault: bifoldrDefault, 
    bifor_: bifor_, 
    bisequence_: bisequence_, 
    bitraverse_: bitraverse_
};
