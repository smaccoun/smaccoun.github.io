// Generated by psc version 0.10.7

// | This module contains various types and functions to allow you to spawn and

// | interact with child processes.

// |

// | It is intended to be imported qualified, as follows:

// |

// | ```purescript

// | import Node.ChildProcess (ChildProcess, CHILD_PROCESS)

// | import Node.ChildProcess as ChildProcess

// | ```

// |

// | The [Node.js documentation](https://nodejs.org/api/child_process.html)

// | will probably also be useful to read if you want to use this module.
"use strict";
var $foreign = require("./foreign");
var Prelude = require("../Prelude");
var Control_Alt = require("../Control.Alt");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Exception = require("../Control.Monad.Eff.Exception");
var Control_Monad_Eff_Exception_Unsafe = require("../Control.Monad.Eff.Exception.Unsafe");
var Data_Foreign = require("../Data.Foreign");
var Data_Function_Uncurried = require("../Data.Function.Uncurried");
var Data_Maybe = require("../Data.Maybe");
var Data_Nullable = require("../Data.Nullable");
var Data_Posix = require("../Data.Posix");
var Data_Posix_Signal = require("../Data.Posix.Signal");
var Data_StrMap = require("../Data.StrMap");
var Node_Buffer = require("../Node.Buffer");
var Node_FS = require("../Node.FS");
var Node_Stream = require("../Node.Stream");
var Unsafe_Coerce = require("../Unsafe.Coerce");
var Data_Show = require("../Data.Show");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Functor = require("../Data.Functor");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Control_Bind = require("../Control.Bind");

// | Behaviour for standard IO streams (eg, standard input, standard output) of

// | a child process.

// |

// | * `Pipe`: creates a pipe between the child and parent process, which can

// |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`

// |   functions.

// | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and

// |   connect it to the stream.

// | * `ShareStream`: Connect the supplied stream to the corresponding file

// |    descriptor in the child.

// | * `ShareFD`: Connect the supplied file descriptor (which should be open

// |   in the parent) to the corresponding file descriptor in the child.
var Pipe = (function () {
    function Pipe() {

    };
    Pipe.value = new Pipe();
    return Pipe;
})();

// | Behaviour for standard IO streams (eg, standard input, standard output) of

// | a child process.

// |

// | * `Pipe`: creates a pipe between the child and parent process, which can

// |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`

// |   functions.

// | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and

// |   connect it to the stream.

// | * `ShareStream`: Connect the supplied stream to the corresponding file

// |    descriptor in the child.

// | * `ShareFD`: Connect the supplied file descriptor (which should be open

// |   in the parent) to the corresponding file descriptor in the child.
var Ignore = (function () {
    function Ignore() {

    };
    Ignore.value = new Ignore();
    return Ignore;
})();

// | Behaviour for standard IO streams (eg, standard input, standard output) of

// | a child process.

// |

// | * `Pipe`: creates a pipe between the child and parent process, which can

// |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`

// |   functions.

// | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and

// |   connect it to the stream.

// | * `ShareStream`: Connect the supplied stream to the corresponding file

// |    descriptor in the child.

// | * `ShareFD`: Connect the supplied file descriptor (which should be open

// |   in the parent) to the corresponding file descriptor in the child.
var ShareStream = (function () {
    function ShareStream(value0) {
        this.value0 = value0;
    };
    ShareStream.create = function (value0) {
        return new ShareStream(value0);
    };
    return ShareStream;
})();

// | Behaviour for standard IO streams (eg, standard input, standard output) of

// | a child process.

// |

// | * `Pipe`: creates a pipe between the child and parent process, which can

// |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`

// |   functions.

// | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and

// |   connect it to the stream.

// | * `ShareStream`: Connect the supplied stream to the corresponding file

// |    descriptor in the child.

// | * `ShareFD`: Connect the supplied file descriptor (which should be open

// |   in the parent) to the corresponding file descriptor in the child.
var ShareFD = (function () {
    function ShareFD(value0) {
        this.value0 = value0;
    };
    ShareFD.create = function (value0) {
        return new ShareFD(value0);
    };
    return ShareFD;
})();

// | Specifies how a child process exited; normally (with an exit code), or

// | due to a signal.
var Normally = (function () {
    function Normally(value0) {
        this.value0 = value0;
    };
    Normally.create = function (value0) {
        return new Normally(value0);
    };
    return Normally;
})();

// | Specifies how a child process exited; normally (with an exit code), or

// | due to a signal.
var BySignal = (function () {
    function BySignal(value0) {
        this.value0 = value0;
    };
    BySignal.create = function (value0) {
        return new BySignal(value0);
    };
    return BySignal;
})();
var ChildProcess = function (x) {
    return x;
};

// | Convert a ChildProcess.Error to a standard Error, which can then be thrown

// | inside an Eff or Aff computation (for example).
var toStandardError = Unsafe_Coerce.unsafeCoerce;
var toActualStdIOBehaviour = function (b) {
    if (b instanceof Pipe) {
        return Unsafe_Coerce.unsafeCoerce("pipe");
    };
    if (b instanceof Ignore) {
        return Unsafe_Coerce.unsafeCoerce("ignore");
    };
    if (b instanceof ShareFD) {
        return Unsafe_Coerce.unsafeCoerce(b.value0);
    };
    if (b instanceof ShareStream) {
        return Unsafe_Coerce.unsafeCoerce(b.value0);
    };
    throw new Error("Failed pattern match at Node.ChildProcess line 382, column 28 - line 386, column 33: " + [ b.constructor.name ]);
};
var toActualStdIOOptions = Data_Functor.map(Data_Functor.functorArray)(function ($31) {
    return Data_Nullable.toNullable(Data_Functor.map(Data_Maybe.functorMaybe)(toActualStdIOBehaviour)($31));
});

// | Spawn a child process. Note that, in the event that a child process could

// | not be spawned (for example, if the executable was not found) this will

// | not throw an error. Instead, the `ChildProcess` will be created anyway,

// | but it will immediately emit an 'error' event.
var spawn = function (cmd) {
    return function (args) {
        var convertOpts = function (opts) {
            return {
                cwd: Data_Maybe.fromMaybe($foreign["undefined"])(opts.cwd), 
                stdio: toActualStdIOOptions(opts.stdio), 
                env: Data_Nullable.toNullable(opts.env), 
                detached: opts.detached, 
                uid: Data_Maybe.fromMaybe($foreign["undefined"])(opts.uid), 
                gid: Data_Maybe.fromMaybe($foreign["undefined"])(opts.gid)
            };
        };
        return function ($32) {
            return $foreign.spawnImpl(cmd)(args)(convertOpts($32));
        };
    };
};
var showExit = new Data_Show.Show(function (v) {
    if (v instanceof Normally) {
        return "Normally " + Data_Show.show(Data_Show.showInt)(v.value0);
    };
    if (v instanceof BySignal) {
        return "BySignal " + Data_Show.show(Data_Posix_Signal.showSignal)(v.value0);
    };
    throw new Error("Failed pattern match at Node.ChildProcess line 147, column 3 - line 147, column 44: " + [ v.constructor.name ]);
});
var runChildProcess = function (v) {
    return v;
};

// | Create pipes for each of the three standard IO streams.
var pipe = Data_Functor.map(Data_Functor.functorArray)(Data_Maybe.Just.create)([ Pipe.value, Pipe.value, Pipe.value ]);

// | The process ID of a child process. Note that if the process has already

// | exited, another process may have taken the same ID, so be careful!
var pid = function ($33) {
    return (function (v) {
        return v.pid;
    })(runChildProcess($33));
};
var onMessage = $foreign.mkOnMessage(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
var mkExit = function (code) {
    return function (signal) {
        var fromSignal = Control_Bind.composeKleisli(Data_Maybe.bindMaybe)(Data_Nullable.toMaybe)(function ($34) {
            return Data_Functor.map(Data_Maybe.functorMaybe)(BySignal.create)(Data_Posix_Signal.fromString($34));
        });
        var fromCode = function ($35) {
            return Data_Functor.map(Data_Maybe.functorMaybe)(Normally.create)(Data_Nullable.toMaybe($35));
        };
        var $20 = Control_Alt.alt(Data_Maybe.altMaybe)(fromCode(code))(fromSignal(signal));
        if ($20 instanceof Data_Maybe.Just) {
            return $20.value0;
        };
        if ($20 instanceof Data_Maybe.Nothing) {
            return Control_Monad_Eff_Exception_Unsafe.unsafeThrow("Node.ChildProcess.mkExit: Invalid arguments");
        };
        throw new Error("Failed pattern match at Node.ChildProcess line 152, column 3 - line 155, column 3: " + [ $20.constructor.name ]);
    };
};
var onClose = $foreign.mkOnClose(mkExit);
var onExit = $foreign.mkOnExit(mkExit);
var mkEff = Unsafe_Coerce.unsafeCoerce;
var send = function (msg) {
    return function (handle) {
        return function (v) {
            return mkEff(function (v1) {
                return v.send(msg, handle);
            });
        };
    };
};
var missingStream = function (str) {
    return "Node.ChildProcess: stream not available: " + (str + ("\x0aThis is probably " + ("because you passed something other than Pipe to the stdio option when " + "you spawned it.")));
};

// | The standard error stream of a child process. Note that this is only

// | available if the process was spawned with the stderr option set to "pipe".
var stderr = function ($36) {
    return $foreign.unsafeFromNullable(missingStream("stderr"))((function (v) {
        return v.stderr;
    })(runChildProcess($36)));
};

// | The standard input stream of a child process. Note that this is only

// | available if the process was spawned with the stdin option set to "pipe".
var stdin = function ($37) {
    return $foreign.unsafeFromNullable(missingStream("stdin"))((function (v) {
        return v.stdin;
    })(runChildProcess($37)));
};

// | The standard output stream of a child process. Note that this is only

// | available if the process was spawned with the stdout option set to "pipe".
var stdout = function ($38) {
    return $foreign.unsafeFromNullable(missingStream("stdout"))((function (v) {
        return v.stdout;
    })(runChildProcess($38)));
};

// | Send a signal to a child process. It's an unfortunate historical decision

// | that this function is called "kill", as sending a signal to a child

// | process won't necessarily kill it.
var kill = function (sig) {
    return function (v) {
        return mkEff(function (v1) {
            return v.kill(Data_Posix_Signal.toString(sig));
        });
    };
};

// | Share stdin with stdin, stdout with stdout, and stderr with stderr.
var inherit = Data_Functor.map(Data_Functor.functorArray)(Data_Maybe.Just.create)([ new ShareStream($foreign.process.stdin), new ShareStream($foreign.process.stdout), new ShareStream($foreign.process.stderr) ]);

// | Ignore all streams.
var ignore = Data_Functor.map(Data_Functor.functorArray)(Data_Maybe.Just.create)([ Ignore.value, Ignore.value, Ignore.value ]);
var disconnect = function ($39) {
    return (function (v) {
        return v.disconnect;
    })(runChildProcess($39));
};
var defaultSpawnOptions = {
    cwd: Data_Maybe.Nothing.value, 
    stdio: pipe, 
    env: Data_Maybe.Nothing.value, 
    detached: false, 
    uid: Data_Maybe.Nothing.value, 
    gid: Data_Maybe.Nothing.value
};
var defaultExecOptions = {
    cwd: Data_Maybe.Nothing.value, 
    env: Data_Maybe.Nothing.value, 
    timeout: Data_Maybe.Nothing.value, 
    maxBuffer: Data_Maybe.Nothing.value, 
    killSignal: Data_Maybe.Nothing.value, 
    uid: Data_Maybe.Nothing.value, 
    gid: Data_Maybe.Nothing.value
};
var convertExecOptions = function (opts) {
    return Unsafe_Coerce.unsafeCoerce({
        cwd: Data_Maybe.fromMaybe($foreign["undefined"])(opts.cwd), 
        env: Data_Maybe.fromMaybe($foreign["undefined"])(opts.env), 
        timeout: Data_Maybe.fromMaybe($foreign["undefined"])(opts.timeout), 
        maxBuffer: Data_Maybe.fromMaybe($foreign["undefined"])(opts.maxBuffer), 
        killSignal: Data_Maybe.fromMaybe($foreign["undefined"])(opts.killSignal), 
        uid: Data_Maybe.fromMaybe($foreign["undefined"])(opts.uid), 
        gid: Data_Maybe.fromMaybe($foreign["undefined"])(opts.gid)
    });
};

// | Similar to `spawn`, except that this variant will:

// | * run the given command with the shell,

// | * buffer output, and wait until the process has exited before calling the

// |   callback.

// |

// | Note that the child process will be killed if the amount of output exceeds

// | a certain threshold (the default is defined by Node.js).
var exec = function (cmd) {
    return function (opts) {
        return function (callback) {
            return $foreign.execImpl(cmd)(convertExecOptions(opts))(function (err) {
                return function (stdout$prime) {
                    return function (stderr$prime) {
                        return callback({
                            error: Data_Nullable.toMaybe(err), 
                            stdout: stdout$prime, 
                            stderr: stderr$prime
                        });
                    };
                };
            });
        };
    };
};

// | Like `exec`, except instead of using a shell, it passes the arguments

// | directly to the specified command.
var execFile = function (cmd) {
    return function (args) {
        return function (opts) {
            return function (callback) {
                return $foreign.execFileImpl(cmd)(args)(convertExecOptions(opts))(function (err) {
                    return function (stdout$prime) {
                        return function (stderr$prime) {
                            return callback({
                                error: Data_Nullable.toMaybe(err), 
                                stdout: stdout$prime, 
                                stderr: stderr$prime
                            });
                        };
                    };
                });
            };
        };
    };
};
var connected = function (v) {
    return mkEff(function (v1) {
        return v.connected;
    });
};
module.exports = {
    Normally: Normally, 
    BySignal: BySignal, 
    Pipe: Pipe, 
    Ignore: Ignore, 
    ShareStream: ShareStream, 
    ShareFD: ShareFD, 
    connected: connected, 
    defaultExecOptions: defaultExecOptions, 
    defaultSpawnOptions: defaultSpawnOptions, 
    disconnect: disconnect, 
    exec: exec, 
    execFile: execFile, 
    ignore: ignore, 
    inherit: inherit, 
    kill: kill, 
    onClose: onClose, 
    onExit: onExit, 
    onMessage: onMessage, 
    pid: pid, 
    pipe: pipe, 
    send: send, 
    spawn: spawn, 
    stderr: stderr, 
    stdin: stdin, 
    stdout: stdout, 
    toStandardError: toStandardError, 
    showExit: showExit, 
    fork: $foreign.fork, 
    onDisconnect: $foreign.onDisconnect, 
    onError: $foreign.onError
};
