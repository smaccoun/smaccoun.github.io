// Generated by psc version 0.10.7
"use strict";
var $foreign = require("./foreign");
var Data_CommutativeRing = require("../Data.CommutativeRing");
var Data_Ring = require("../Data.Ring");
var Data_Semiring = require("../Data.Semiring");
var Data_Unit = require("../Data.Unit");

// | The `EuclideanRing` class is for commutative rings that support division.

// |

// | Instances must satisfy the following law in addition to the `Ring`

// | laws:

// |

// | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`

// | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``

// |   where `degree a > 0` and `degree a <= degree (a * b)`
var EuclideanRing = function (__superclass_Data$dotCommutativeRing$dotCommutativeRing_0, degree, div, mod) {
    this["__superclass_Data.CommutativeRing.CommutativeRing_0"] = __superclass_Data$dotCommutativeRing$dotCommutativeRing_0;
    this.degree = degree;
    this.div = div;
    this.mod = mod;
};

// | The `EuclideanRing` class is for commutative rings that support division.

// |

// | Instances must satisfy the following law in addition to the `Ring`

// | laws:

// |

// | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`

// | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``

// |   where `degree a > 0` and `degree a <= degree (a * b)`
var mod = function (dict) {
    return dict.mod;
};
var euclideanRingUnit = new EuclideanRing(function () {
    return Data_CommutativeRing.commutativeRingUnit;
}, function (v) {
    return 1;
}, function (v) {
    return function (v1) {
        return Data_Unit.unit;
    };
}, function (v) {
    return function (v1) {
        return Data_Unit.unit;
    };
});
var euclideanRingNumber = new EuclideanRing(function () {
    return Data_CommutativeRing.commutativeRingNumber;
}, function (v) {
    return 1;
}, $foreign.numDiv, function (v) {
    return function (v1) {
        return 0.0;
    };
});
var euclideanRingInt = new EuclideanRing(function () {
    return Data_CommutativeRing.commutativeRingInt;
}, $foreign.intDegree, $foreign.intDiv, $foreign.intMod);

// | The `EuclideanRing` class is for commutative rings that support division.

// |

// | Instances must satisfy the following law in addition to the `Ring`

// | laws:

// |

// | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`

// | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``

// |   where `degree a > 0` and `degree a <= degree (a * b)`
var div = function (dict) {
    return dict.div;
};

// | The `EuclideanRing` class is for commutative rings that support division.

// |

// | Instances must satisfy the following law in addition to the `Ring`

// | laws:

// |

// | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`

// | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``

// |   where `degree a > 0` and `degree a <= degree (a * b)`
var degree = function (dict) {
    return dict.degree;
};
module.exports = {
    EuclideanRing: EuclideanRing, 
    degree: degree, 
    div: div, 
    mod: mod, 
    euclideanRingInt: euclideanRingInt, 
    euclideanRingNumber: euclideanRingNumber, 
    euclideanRingUnit: euclideanRingUnit
};
